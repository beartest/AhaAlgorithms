《啊哈！算法》  —— Aha! Algorithms
啊哈磊（纪磊） 著
网址： www.ahalei.com(有讨论区，有算法挑战题，很有趣)
微博：weibo.com/ahalei

书中的代码是C语言的，我用javascript实现了其中的部分代码，序列号我喜欢从0开始。

第1章 一大波数正在靠近——排序
	第1节 最快最简单的排序——桶排序
		../sort/BucketSort.js
		对0-10整数数组进行简单桶排序。
	第2节 邻居好说话——冒泡排序
		../sort/BubbleSort.js
		对数字数组进行冒泡排序，以及对学生姓名按成绩排序。
	第3节 最常用的排序——快速排序
		../sort/QuickSort.js
		对数字数组进行快速排序。
	第4节 小哼买书
		../sort/BuyBooks.js
		对书序列号去重排序，第一种方法使用桶排序，第二种使用冒泡排序，输出时去重。
第2章 栈、队列、链表
	第1节 解密QQ号——队列
		../stack&queue&linklist/qqQueue.js
		解码一串数字，一种简单的加密方法。
	第2节 解密回文——栈
	第3节 纸牌游戏——小猫钓鱼
		../stack&queue&linklist/cardGame.js
		一种在山西被称为拉火车，在湖南被称为捡狗屎的扑克游戏。两人轮流出牌，和拉火车不同，出牌后获得牌的人不会继续出牌，代码实现时注意，第一个人出牌后手牌为空时，游戏结束。
	第4节 链表
	第5节 模拟链表
		队列、栈、链表我没有用js实现类，仅用数组模拟操作，具体的实现可参见《数据结构与算法JavaScript描述》。
第3章 枚举！很暴力
	第1节 坑爹的奥数
		..\enumeration\equation.js
		使用1-9的整数构造 XXX + XXX = XXX 的等式。枚举解法共两种，第二种用桶排序去重，虽然代码量虽然减少了，实际效率更低。
	第2节 炸弹人
		..\enumeration\bomber.js
		炸弹人游戏枚举解法，不考虑地图的可达性，用二维数组模拟地图，#代表墙体，G代表敌人，.代表空白区域。
	第3节 火柴棍等式
		..\enumeration\match.js
		用n根火柴排成 A+B=C，其中加号和等号一共用掉4根。 当n为24时，A、B、C最大不会超过1111，这点很重要。
	第4节 数的全排列
		..\enumeration\fullPermutation.js
		123的全排列暴力枚举。
第4章 万能的搜索
	第1节 不撞南墙不回头——深度优先搜索
		../search/equationDFS.js
		使用1-9的整数构造 XXX + XXX = XXX 的等式,深度优先搜索解法（depth-first search）。可以认为本质是全排列。
	第2节 解救小哈
		../search/mazeDFS.js
		迷宫A点到B点，需要绕过障碍物，深度优先搜索解法。用数组模拟迷宫地图，0代表可通行，1代表障碍物。可以使用一个4*2的数组来存储右下左上四个方向的增量，方便循环调用，注意起始时初始点的book值设置为1。
	第3节 层层递进——广度优先搜索
		../search/mazeBFS.js
		迷宫问题，广度优先搜索解法（breadth-first search）。设置一个Node类，包含xy坐标、步数，前一个节点在队列中存储位置。用数组模拟队列存储节点，这里由于需要输出路径，把过程中的点都存储在队列中不出队，只是修改curIndex来指定队列当前处理的位置。如果不需要终点入队，判断到达终点的代码可以放在入队和边界判断之前。
	第4节 再解炸弹人
		考虑路径的可达性。和第3章第2节的地图略有不同，(6,11)的墙改为平地。
		../search/bomberBFS.js
		炸弹人，广度优先搜索解法。获取某一点的杀敌数getnum方法，也使用存储四个方向增量的数组，将四个while，改为一个for循环。book数组其实不需要全部赋值为0，只需要设置book[i]=[]，这时候book的每个值都为undified,判断的时候用 book[tx][ty] != 1。
		../search/bomberDFS.js
		炸弹人，深度优先搜索解法。书中的代码加了边界的判断，这里最外层一定是墙，所以可以不加。而且和第一节中的深度优先搜索不同，不需要回调完再将book[tx][ty]设为0。
	第5节 宝岛探险
		用数组模拟地图，数字代表海拔，0代表海洋，1-9代表陆地。计算跳伞落地岛的面积。
		../search/islandBFS.js
		岛屿探索，广度优先搜索解法。area和sum都是计算面积的，位置不用，结果一样。
		../search/islandDFS.js
		岛屿搜索，深度优先搜索解法。再三强调，一定要将初始点的book值设置为1。
		../search/islandColorDFS.js
		../search/islandColorBFS.js
		这种算法又称为着色法。使用js可以方便的制作进行表格染色动画，比用控制台输出要直观的多。将搜索到的格子用队列存储,然后用setTimeout,逐个染色。可以清楚的观察到深度优先搜索和广度优先搜索的不同。
		../search/floodfillDFS.js
		求图中共有多少个独立小岛。
		即求图中独立子图的个数。Floodfill漫水填充法，又称种子填充法。
	第6节 水管工游戏
		../search/pipe.js
		水管工游戏，只有弯管和直管两种，算方向共六种。
		1-上右 2-下右 3-左下 4-左上 5-左右 6上下
		进水方向 1-左 2-上 3-右 4-下
		深度优先搜索，直管的下一个位置很确定，弯管下一个位置有两种情况。设置flag标记是否有可行的铺设方案。
第5章 图的遍历
	第1节 深度和广度优先究竟是指啥
		使用Infinity代表不连通。
		../traversingGraph/traversingDFS.js
		图的深度优先遍历
		../traversingGraph/traversingBFS.js
		图的广度优先遍历
	第2节 城市地图——图的深度优先遍历
		../traversingGraph/mapDFS.js
		0号点到4号点的最短距离深度优先遍历求解。
	第3节 最少转机——图的广度优先遍历
		../traversingGraph/transferBFS.js
		0号点到4号点经过节点数最少的广度优先遍历求解。
第6章 最短路径
	第1节 只有五行的算法——Floyd-Warshall
		../shortestPath/Floyd-Warshall.js
		多源最短路径。使用邻接矩阵存储边，空间复杂度O(N^2),时间复杂度O(N^3)。不能解决带负权回路的图。
		三层循环，均为N次。
	第2节 Dijkstra算法——单源最短路
		../shortestPath/DijkstraMatrix.js
		稠密图，使用邻接矩阵存储边,空间复杂度O(N^2)。
		最外层循环N-1次，内部先循环N次获取路径最小的确定值，再循环N次松弛路径。
		../shortestPath/AdjacencyTable.js
		实现邻接表的存储
		../shortestPath/DijkstraTable.js
		稀疏图，使用邻接表存储边,空间复杂度O(M)，循环松弛路径的时候，只需要对连通的点进行松弛。
		查找路径最小的确定值时，时间复杂度O(N)，可以使用下一章的堆来优化，使其中一部分降低到O(logN)。
	第3节 Bellman-Ford——解决负权边
		../shortestPath/BellmanFord.js
		使用邻接表存储，空间复杂度O(M);
		代码量很少，关键代码只有4行，时间复杂度O(MN)。
		外层循环N-1次，这里不是对顶点遍历，而是进行N-1轮的松弛。因为N个顶点的图中，任意两点之间的最短路径最多包含N-1条边。
		内层循环M次，循环所有路径。
		可以检测一个图是否含有负权回路。在N-1轮松弛之后，再成功松弛，则存在负权回路。
		因为最外层是最多需要N-1次，可能在此之前就已经完成了全部松弛，可以添加一个变量check，看本轮松弛是否发生。这让我想到冒泡排序。
	第4节 Bellman-Ford的队列优化
		../shortestPath/BellmanFordQueue.js
		使用队列优化Bellman-Ford。使用邻接表存储边。
		使用book来避免重复入队，注意，出队的元素book要重新设置为0。
	第5节 最短路径算法对比分析
		邻接矩阵适用于稠密图，和顶点关系密切。
		邻接表使用于稀疏图，和边关系密切。
		下面分别说明几种算法的空间复杂度、 时间复杂度、适用情况、负权
		Floyd: O(N^2) O(N^3) 稠密图  支持负权
		Dijkstra: O(M) O((M+N)logN) 稠密图 不支持负权
		Bellman-Ford:  O(M) O(NM) 稀疏图 支持负权
		Bellman-Ford队列优化:  O(M) 最大O(NM) 稀疏图 支持负权 
第7章 神奇的数
	第1节 开启“树”之旅
		树是指任意两个结点间有且只有一条路径的无向图，即没有回路的连通无向图。
	第2节 二叉树
		满二叉树和完全二叉树，满足父结点k，左儿子2K，右儿子2k+1；这是从1开始计数的情况。如果从0开始计数，左儿子2k+1，右儿子2k+2。
		一个完全二叉树有N个结点，这个完全二叉树的高度为logN。
	第3节 堆——神奇的优先队列
		堆是一种特殊的二叉树。
		所有的父结点都比子结点要小的，称之为最小堆。
		所有的父结点都比子结点要大的，称之为最大堆。
		这里用数组来存储堆。
		../Tree/HeapSiftDown.js
		删除最小值并添加一个新数，从堆的顶点开始向下调整。时间复杂度O(logN)。
		从0计数，当前节点k，左节点2k+1，右节点2k+2。
		思路：
		1.第一个节点为最小节点，替换为要插入的数
		2.如果存在左节点，左节点小于当前节点，则记录左节点，否则记录当前节点
		3.如果存在右节点，右节点小于左节点，则记录右节点
		4.如果记录的节点不是当前节点，交换当前节点和记录节点。
		    也就是说把子节点中较小的一个和当前节点替换。
		5.如果记录节点是当前节点，循环2-5。直到没有子节点，或子节点都小于当前节点，跳出循环。
		这里和作者的不同，结点不是从1开始，而是从0开始计数。而且不用flag来判断循环条件，结束时用break跳出循环。
		../Tree/HeapSiftUp.js
		新增一个值，从堆的末尾开始向上调整。时间复杂度O(logN)。
		从0计数，当前节点k，父节点Math.ceil(k/2)-1。
		思路：
		和父节点比较大小，小于父节点的交换位置。循环直到根节点或不小于父节点。
		../Tree/CreateHeapSiftUp.js
		从空的堆开始，依次插入每个元素。时间复杂度O(NlogN)。
		../Tree/CreateHeapSiftDown.js
		构建完全二叉树，从底部逐渐判断子数是否符合最小数。时间复杂度O(N)。
		共n个元素，从第 Math.floor(n / 2)-1 个开始处理。
		../Tree/MaximumHeapSort.js
		堆排序，时间复杂度O(NlogN),和快速排序一样。
		最小堆，循环返回堆顶元素，把末尾元素弹出赋值到堆顶，并向下调整。
		../Tree/MinimumHeapSort.js
		最大堆，处理大小为n的堆，将堆顶和末尾互换，然后减小堆的大小，向下调整，再处理大小为n-1的堆。
		../Tree/getKth.js
		堆可以被用来求数列第K大的数和第K小的数。
		求第K大的数，建立大小K的最小堆，比堆顶小的元素略过，比栈顶大的，替换栈顶，向下调整。
		求第K小的数，建立大小K的最大堆，比堆顶大的元素略过，比栈顶小的，替换栈顶，向下调整。
	第4节 擒贼先擒王——并查集
		../Tree/UnionFind.js
		查找犯罪集团，假设第一个值为首领。
		getf(v)递归查找集团首领，使用路径压缩，每次在函数返回的时候，顺带把路上遇到的人的值改为集团的最高领导人。可以提高以后查找集团最高领导的速度。
		merge(v,u)合并两个集团。
		最后数组中值和索引相同的，就是集团的首领。
第8章 更多精彩算法
	第1节 镖局运镖——图的最小生成树
		../More/Kruskal.js
		最小生成树（MinimumSpaningTree），是我觉得比较难的部分。第一节介绍Kruskal算法，首先将边按权重快速排序，然后根据并查法，连接顶点，共连接n-1条边，则形成最小生成树。
		计算时间复杂度，快排O(MlogM),m条边中找到n-1条边O(MlogN),总算法O(MlogM+MlogN),通常M远远大于N，最终时间复杂度O(MlogM)。
	第2节 再谈最小生成树
		Prim算法也叫DJP算法。注意边在转化为邻接矩阵或邻接表的时候，由于是无向图，需要进行两次赋值。
		../More/PrimMatrix.js
		用邻接矩阵存储无向图，然后使用类似于Dijkstra算法的计算方式，不断计算到确定数的最短路径。区别在于Dijkstra算法中dis[v] = dis[u] + e[u][v];，该算法中dis[v] = e[u][v];。
		时间复杂度O(N^2)。
		../More/PrimTable.js
		使用邻接表和堆进行优化。借助“堆”,选边复杂度O(M),再使用邻接表，时间复杂度降低到O(MlogN)。
	第3节 重要城市——图的割点
		../More/CutVertexMatrix.js
		割点算法，邻接矩阵存储，时间复杂度O(N^2)。
		../More/CutVertexTable.js
		割点算法，邻接表存储，时间复杂度O(M+N)。
	第4节 关键道路——图的割边
		../More/CutEdgeMatrix.js
		../More/CutEdgeTable.js
		割边，也称桥。割边算法只需要将割点算法修改一个符号就可以。
		将low[i] >= num[cur]改为low[i] > num[cur]，如果当前点cur是割点。>=表示i不经过cur点，无法回到祖先。>表示i不经过cur，无法回到父亲和祖先。
		割边算法时间复杂度和割点算法一样。
	第5节 我要做月老——二分图最大匹配
		二分图是无向图。
		../More/BipartiteGraph.js
		匈牙利算法，涉及增广路。时间复杂度O（NM）。
第9章 还能更好吗——微软亚洲研究院面试
		主元素问题(“寻找多数问题”)。判断一个数出现的次数超过50%。
		我的想法是排序，然后获取中间的元素。再根据中间元素遍历数组，记录出现次数。
		作者想到了这种算法，并且还講了了堆排序方法，并进行离散化。
		又提到了快排的方法，优化后的时间复杂度接近O(N)。
		../Better/PivotElement.js
		这种算法时间复杂度最坏为O(N)，前提是已知一定含有主元素。算法思想是把主元素看成1，其他的都当做-1。设置第一个为当前主元素，count=1，和当前主元素值相同的就+1，不同的-1。count为0的时候，把下一个元素设为当前主元素，重复操作。由于主元素的数量大于一半，所以剩下的必然是主元素。
